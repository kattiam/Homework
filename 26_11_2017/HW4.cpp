/*
Напишите программу, которая выводит все натуральные числа-палиндромы
длины n,
делящиеся на 9, в порядке возрастания.
Комментарий. Программа должна состоять из:
         - процедуры print_palindrom(), принимающей в себя длину палиндрома
         - чтения n - длины палиндрома
         - применения print_palindrom() к n
Программа должна быть разумной по времени(перебор всех чисел - не вариант)
*/

/*
Алгоритм для четного палиндрома:
Минимальный палиндром длины N = 10..0880...1
Для получения каждого следующего палиндрома
прибавляем к левой части предыдущего 9 и выодим
левую часть и цифры левой части в обратном порядке

Алгоритм для нечетного палиндрома:
Любое число можно педставить в виде 9*k+S, где S- сумма цифр.
Значит остатки r от деления левой и правой части палиндрома при делении
на 9 равны,
а центральная цифра b - это дополнение до 9 суммы остатков от деления на 9.
Тогда, если известна левая часть и центр b. то следующий палиндром можно
получить
прибавлением 1 к левой части и определением b след. образом:
- общий остаток был равен r=9-b
- при добавлении 1 к левой части остаток увеличился на 2 и стал r=
(9-b+2) % 9.
   ( %9 чтобы не получались щтрицательные b, когда r>9.
- новый b= 9 - r;
- если b = 0, то прибавлять 1 к левой части не нада, а просто b=9
*/

#include <cstdlib>
#include <iostream>

using namespace std;

// Вывод цифр числа в обратном порядке
long printRight(long k){
     while(k > 0){
      cout << ( k % 10 );
      k /= 10;
     }
}

// Число 10 в степени  N/2
long get10(int N){
     int n = N/2;
     int k = 1;
     for( int i = 0; i < n; i++) k *=10;
     return k;
}

/*
Вывод палиндромов нечетной длины N
*/
void oddPalindrom(int N){
     long maxleft = get10(N);  // 10^(N/2)
     long left = maxleft/10; // левая часть самого младшего палиндрома
     int b = 7;  // центральная цифра
     while( left < maxleft){
         cout << left << b;
         printRight(left);
         cout << " ";
         if( b == 0){    // b = 9 без изменения левой части
           b = 9;
           continue;
         }
         //определяем след. left  и b
         left +=1;  //увеличиваем на 1 левую часть
         int r = 9 - b;  //  у предыдущей левой части остаток был 9-b
         r += 2;         // увеличился на 2 и
         r = r % 9;      // стал r % 9
         if( r == 0){
             b = 0;
             continue;
         }
         b = 9 - r;      // новый b дополнение остатка до 9
     }
     cout << endl;
}

/*
Минимальный четный палиндром 10...0880...0
Начинаем с левой части 10...08 и прибавляем 9 для каждой следующей
Выводим левую часть , а потом ее цифры в обратном порядке
*/
void evenPalindrom(int N){
     long maxleft = get10(N);  // 10^(N/2)
     long left = maxleft/10 + 8; // левая часть самого младшего палиндрома
     while( left < maxleft){
         cout << left;
         printRight(left);  // вывод левой части в обратном порядке цифр
         cout << " ";
         left += 9;
     }
     cout << endl;
}

print_palindrom(int N){
     if( N % 2 == 0) evenPalindrom(N);  // четный
     else oddPalindrom(N); // нечетный

}

int main(int argc, char** argv) {
     int N;
     while(1){
       cout << "Enter N or 0 to quit" << endl;
       cin >> N;
       if( N == 0 ) break;
       if( N == 1 ){
           cout << 0 << " " << "9" << endl;
           continue;
       }
       if( N == 2 ){
           cout << "99" << endl;
           continue;
       }
       print_palindrom(N);
     }

     system("PAUSE");
     return EXIT_SUCCESS;
}
